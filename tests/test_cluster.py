#!/usr/bin/env python

######################################################.
# 		        Testing with pytest: 	             #
#                  CLUSTER module                    #
######################################################.

import os
from os import path
import pytest
import shutil
import subprocess
import pandas as pd
from almos.cluster import cluster

# saves the working directory
path_cluster = os.getcwd() 
path_tests = os.getcwd() + "/tests"



# tests for CLUSTER
@pytest.mark.parametrize(
    "test_job",
    [
        # test the route that GOES through AQME
        ("test_cluster1a.csv"),  # csv with column named batch, sys.exit(), csv_name not defined, csv_name not found, n_clusters not defined
        ("test_cluster1b.csv"),  # --qdescp_atoms, --qdescp_solvent      
        ("test_cluster2.csv"),   # duplicate row, invalid SMILE, duplicate SMILE, test fix_cols_names, columns with single data 
        ("test_cluster3a.csv"),  # csv without SMILES or --name defined, sys.exit()
        ("test_cluster3b.csv"),  # csv without code_name , sys.exit()
    
         
        # # # test the route that DON'T GO through AQME       
        ("test_cluster4.csv"),   # set --y, but it doesn't appear in the CSV, sys.exit()
        ("test_cluster5.csv"),   # set --name, but it doesn't appear in the CSV, sys.exit()
        ("test_cluster6.csv"),   # set --ignore, but it doesn't appear in the CSV, sys.exit()
        ("test_cluster7a.csv"),  # categorical_transform, auto_fill_knn
        ("test_cluster7b.csv"),  # set --not_autofil, sys.exit()
        ("test_cluster7c.csv"),  # set --categorical "numbers"       
        ("test_cluster8.csv"),   # less than three descriptors, sys.exit()
        ("test_cluster9.csv"),   # duplicate in the name column, sys.exit()
    ],
)

def test_CLUSTER(test_job):

    # leave the folders as they were initially to run a different batch of tests
    folders_cluster = ["'batch_0", "aqme"]
    for folder in folders_cluster:
        if os.path.exists(f"{path_cluster}/{folder}"):
            shutil.rmtree(f"{path_cluster}/{folder}")
    # remove CSV files generated by CLUSTER as options.csv
    options_csv = "options.csv"
    if os.path.exists(f'{path_cluster}{options_csv}'):
        os.remove(f'{path_cluster}{options_csv}')
    # remove the DAT file if it exists (it is not in batch_0 folder if the program finishes with sys.exit)
    if os.path.exists("CLUSTER_data.dat"):
        os.remove("CLUSTER_data.dat")
        
    # runs the program with the different tests
    cmd_cluster = [
        "python",
        "-m", "almos",
        "--cluster",
        "--n_clusters", "2",
        "--csv_name", f'{path_tests}/{test_job}'
    ]
    
    not_aqme = [
        "test_cluster4.csv",
        "test_cluster5.csv",  
        "test_cluster6.csv", 
        "test_cluster7a.csv",
        "test_cluster7b.csv",
        "test_cluster7c.csv", 
        "test_cluster8.csv",
        "test_cluster9.csv"
]      
         
    if test_job in not_aqme:
        cmd_cluster += ["--y","yield",
                        "--name","molecules"]  
        
    if test_job == "test_cluster1b.csv":
        cmd_cluster += ["--qdescp_atoms", "[1,2]"]
                      # "--qdescp_solvent", COMPLETE] 
                         
    if test_job == "test_cluster6.csv":
        cmd_cluster += ["--ignore", "['color']"]

    if test_job == "test_cluster7b.csv":
        cmd_cluster += ["--not_autofill"]
        
    if test_job == "test_cluster7c.csv":
        cmd_cluster += ["--categorical", "numbers"]

    # list of tests that finish      
    test_sys = ["test_cluster1b.csv"
                "test_cluster2.csv",
                "test_cluster7a.csv",
                "test_cluster7c.csv",
    ]
     
  
    # list of tests that stop with sys.exit(n)
    test_sys_exit = ["test_cluster1a.csv",
                     "test_cluster3a.csv",
                     "test_cluster3b.csv",
                     "test_cluster4.csv",
                     "test_cluster5.csv",
                     "test_cluster6.csv",
                     "test_cluster7b.csv",
                     "test_cluster8.csv",
                     "test_cluster9.csv"
    ]

    if test_job in test_sys_exit:
        exit_error = subprocess.run(cmd_cluster)
        with open("CLUSTER_data.dat", "r") as file:  # the path of the DAT file is different for the test that finish from those that stop with sys.exit
             dat_file = file.read()

    if test_job == "test_cluster1a.csv":
        assert exit_error.returncode == 1, "The CSV file contains a 'batch' column and it has not exited the program"
        error_1 = f"\nx WARNING. The csv_name provided ({test_job}) already contains a 'batch' column"
        assert error_1 in dat_file, f"The CSV file {test_job} must show a WARNING about the existance of a batch column and it doesn't appear"

        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2
                    )
        assert excinfo.value.code == 1 
        
        # using CLUSTER, csv_name not defined
        with pytest.raises(SystemExit) as excinfo:
            cluster(csv_name = None,
                    n_clusters = 2
                    )
        assert excinfo.value.code == 9 

        # using CLUSTER, csv_name not found
        with pytest.raises(SystemExit) as excinfo:
            cluster(csv_name = f'{path_tests}/csv_not_found.csv',
                    n_clusters = 2
                    )
        assert excinfo.value.code == 10 
        
        # using CLUSTER, n_clusters not defined
        with pytest.raises(SystemExit) as excinfo:
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = None
                    )
        assert excinfo.value.code == 11 
        
    if test_job == "test_cluster3a.csv":
        assert exit_error.returncode == 2, "The CSV file has not column define as smiles and --name has not been defined, and it has not exited the program"
        error_2 = f"\nx WARNING. The csv_name provided ({test_job}) must contain a column called 'SMILES' and another called 'code_name' to generate the descriptors, or else provide the descriptors and a column with the 'name' of the molecules (e.g. --name molecules)"
        assert error_2 in dat_file, f"The CSV file {test_job} must show a WARNING because has not column define as smiles and --name has not been defined"
        
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2
                    )
        assert excinfo.value.code == 2          

    if test_job == "test_cluster3b.csv":
        assert exit_error.returncode == 2, "The CSV file has not column define as code_name and --name has not been defined, and it has not exited the program"
        error_2 = f"\nx WARNING. The csv_name provided ({test_job}) must contain a column called 'SMILES' and another called 'code_name' to generate the descriptors, or else provide the descriptors and a column with the 'name' of the molecules (e.g. --name molecules)"
        assert error_2 in dat_file, f"The CSV file {test_job} must show a WARNING because has not column define as smiles and --name has not been defined"
        
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    ignore = []
                    )
        assert excinfo.value.code == 2    
        
    if test_job == "test_cluster4.csv":
        assert exit_error.returncode == 3,  "--y yield has been defined and the CSV file has not contain the column yield, and it has not exited the program"
        error_3 = f"\nx WARNING. The csv_name provided ({test_job}) does not contain the column idicated as: --y yield"
        assert error_3 in dat_file, f"The CSV file {test_job} must show a WARNING because --y yield has been defined and it doen't appear in the CSV file"
        
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:        
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    y = 'yield',
                    name = 'molecules',
                    ignore = []
                    )
        assert excinfo.value.code == 3   
 
    if test_job == "test_cluster5.csv":
        assert exit_error.returncode == 4, "--name molecules has been defined and the CSV file has not contain the column molecules, and it has not exited the program"  
        error_4 = f"\nx WARNING. The csv_name provided ({test_job}) does not contain the column idicated as: --name molecules"
        assert error_4 in dat_file, f"The CSV file {test_job} must show a WARNING because --name molecules has been defined and it doen't appear in the CSV file"
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:  
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    y = 'yield',
                    name = 'molecules',
                    ignore = []
                    )
        assert excinfo.value.code == 4 
            
    if test_job == "test_cluster6.csv":
        assert exit_error.returncode == 5, "--ignore color has been defined and the CSV file has not contain the column color, and it has not exited the program"    
        error_5 = f"\nx WARNING. Some columns (['color']), named in ignore (['color']), do not exist in the csv_name provided ({test_job}). Please, specify the list ignore correctly"
        assert error_5 in dat_file, f"The CSV file {test_job} must show a WARNING because --ignore color has been defined and it doen't appear in the CSV file"
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:          
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    y = 'yield',
                    name = 'molecules',
                    ignore = "['color']"
                    )
        assert excinfo.value.code == 5    

                        
    if test_job == "test_cluster7b.csv":
        assert exit_error.returncode == 6, "The CSV file has empty spaces in the descriptor columns, --not_autofill has been defined and it has not exited the program" 
        error_6 = f"\nx WARNING. The csv_name provided ({test_job}) has empty spaces in the descriptor columns. If you want them to be auto-completed, don't set --not_autofill, and these will be filled with the auto_fill_knn function."
        assert error_6 in dat_file, f"The CSV file {test_job} must show a WARNING because has empty spaces and --not_autofill has been defined"
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:  
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    y = 'yield',
                    name = 'molecules',
                    not_autofill = True,
                    ignore = []
                    )
        assert excinfo.value.code == 6 
 
        
    if test_job == "test_cluster8.csv":
        assert exit_error.returncode == 7, "The CSV file has less than three columns of descriptors, and it has not exited the program"  
        error_7 = f"\nx WARNING. The csv_name provided ({test_job}) must contain at least three columns of descriptors"
        assert error_7 in dat_file, f"The CSV file {test_job} must show a WARNING because it has lesss than three columns of descriptors"
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:  
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    y = 'yield',
                    name = 'molecules',
                    ignore = []
                    )
        assert excinfo.value.code == 7 
                
    if test_job == "test_cluster9.csv":
        assert exit_error.returncode == 8, "The CSV file has a duplicate in the name column, and it has not exited the program"  
        error_8 = f"\nx WARNING. The csv_name provided ({test_job}) has the next duplicates in the column (molecules) with different values for the other columns of descriptors:"
        assert error_8 in dat_file, f"The CSV file {test_job} must show a WARNING because it has a duplicate in the name column" 
        # using CLUSTER
        with pytest.raises(SystemExit) as excinfo:  
            cluster(csv_name = f'{path_tests}/{test_job}',
                    n_clusters = 2,
                    y = 'yield',
                    name = 'molecules',
                    ignore = []
                    )
        assert excinfo.value.code == 8 
        
        
    if test_job == "test_cluster1b.csv":   
        subprocess.run(cmd_cluster)
        assert path.exists(f"{path_cluster}/batch_0/pca_3d.html")   
       
        # check the names of the files in aqme
        files_of_aqme = [f'AQME-ROBERT_denovo_test_cluster1b_b0.csv', 
                        f'AQME-ROBERT_interpret_test_cluster1b_b0.csv', 
                        f'AQME-ROBERT_full_test_cluster1b_b0.csv', 
                        'QDESCP_data.dat', 
                        'CSEARCH_data.dat',
                        'CSEARCH',
                        'QDESCP']
        
        for file in files_of_aqme:
            destination = f'{path_cluster}/aqme/{file}'
            assert os.path.exists(destination) 
            
        # check the command line used in AQME    
        with open("batch_0/CLUSTER_data.dat", "r") as file:  # the path of the DAT file is different for the test that finish from those that stop with sys.exit
             dat_file_lines = file.readlines()   
        qdescp_atoms_dat = f"o Command line used in AQME: ['python', '-m', 'aqme', '--qdescp', '--input', 'batch_0/test_cluster1b_b0.csv', '--qdescp_atoms', '[1,2]']"    
        assert any (qdescp_atoms_dat in line for line in dat_file_lines)
      
        # check the presence of descriptors of both (C1 and C2) in the CSV file
        df_csv = pd.read_csv('batch_0/test_cluster1b_b0.csv')
        assert 'C1_FOD' in df_csv.columns
        assert 'C2_FOD' in df_csv.columns

        # check the molecules of batch_0 in de DAT file
        with open("batch_0/batch_0.dat", "r") as file:  
            dat_batch_0 = file.read()
        assert ("2a" and "2b") in dat_batch_0

        # using CLUSTER
        cluster(csv_name = f'{path_tests}/{test_job}',
                n_clusters = 2,
                qdescp_atoms = "[1,2]",
                ignore = []
                )        
        
    if test_job == "test_cluster2.csv":
        subprocess.run(cmd_cluster)
        assert path.exists(f"{path_cluster}/batch_0/pca_3d.html") 
          
        # check the names of the files in batch_0 (aqme_workflow == True)
        files_of_batch_0 = [f'test_cluster2_b0.csv', 
                            'batch_0.dat', 
                            'CLUSTER_data.dat',
                            'pca_3d.html']
        for file in files_of_batch_0:
            destination = f'{path_cluster}/batch_0/{file}'
            assert os.path.exists(destination)
            
        # check the molecules of batch_0 in de DAT file
        with open("batch_0/batch_0.dat", "r") as file: 
            dat_batch_0 = file.read()
        assert ("benzaldehyde" and "benzene") in dat_batch_0
          
            
        # open CLUSTER_data.dat to read
        with open("batch_0/CLUSTER_data.dat", "r") as file_cluster: 
            dat_cluster = file_cluster.readlines()
            
        # check duplicate row
        duplicate_row = f"x WARNING. The csv_name provided (test_cluster2.csv) has duplicate rows, only the first one has been kept. The duplicate rows are:"
        assert any (duplicate_row in line for line in dat_cluster)
        
        # check invalid SMILE
        invalid_smile1 = f"x  WARNING. These invalid smiles from (test_cluster2.csv) have been removed:" 
        invalid_smile2 = f" ['R']" 
        assert any (invalid_smile1 in line for line in dat_cluster)    
        assert any (invalid_smile2 in line for line in dat_cluster)
         
        # check duplicate SMILE
        duplicate_smile = f"x WARNING. The csv_name provided (test_cluster2.csv) has duplicate canonicalized SMILES, only the first one has been kept. The duplicate SMILES are:"
        assert any (duplicate_smile in line for line in dat_cluster)
        
        # check test fix_cols_names
        test_cols_names1 = f"o For the clustering, the following columns of the CSV file batch_0/test_cluster2_b0.csv have been ignore:"
        test_cols_names2 = f" ['batch', 'SMILES', 'code_name']"
        assert any (test_cols_names1 in line for line in dat_cluster)
        assert any (test_cols_names2 in line for line in dat_cluster)
        columns_csv = pd.read_csv('batch_0/test_cluster2_b0.csv')  
        assert ('code_name' and 'SMILES') in columns_csv.columns     
                
        # check columns with single data 
        cols_single_data1 = f"x WARNING. The column (Unnamed: 2) in the csv_name provided (test_cluster2.csv) has less than 70% of the data, so it has been deleted"
        cols_single_data2 = f"x WARNING. The column (Unnamed: 3) in the csv_name provided (test_cluster2.csv) has less than 70% of the data, so it has been deleted"
        assert any (cols_single_data1 in line for line in dat_cluster)
        assert any (cols_single_data2 in line for line in dat_cluster)
        
        # check categorical variables (there are not)
        cat_var = f"   - No categorical variables were found"
        assert any (cat_var in line for line in dat_cluster)        
        
        # using CLUSTER
        cluster(csv_name = f'{path_tests}/{test_job}',
                n_clusters = 2,
                ignore = []
                )        

              
    if test_job == "test_cluster7a.csv":     
        subprocess.run(cmd_cluster)
        
        # check the names of the files in batch_0 (aqme_workflow == False)
        files_of_batch_0 = [f'test_cluster7a_b0.csv', 
                            'batch_0.dat', 
                            'CLUSTER_data.dat',
                            'pca_3d.html']
        for file in files_of_batch_0:
            destination = f'{path_cluster}/batch_0/{file}'
            assert os.path.exists(destination) 
               
        # check aqme folder has not been created    
        assert not path.exists(f"{path_cluster}/aqme")   
                 
        # open CLUSTER_data.dat to read
        with open("batch_0/CLUSTER_data.dat", "r") as file_cluster: 
            dat_cluster = file_cluster.readlines()
        
        # check the categorical_transform
        cat_transform_onehot = [f"   A total of 1 categorical variables were converted using the onehot mode in the categorical option:",
                                f"   Initial descriptors:",
                                f"   Generated descriptors:",
                                f"   - blue",
                                f"   - green",
                                f"   - pink",
                                f"   - red"]
        for cat in cat_transform_onehot:
            assert any (cat in line for line in dat_cluster)
        
        # check the auto_fill_knn 
        autofill = f"x WARNING. The csv_name provided (test_cluster7a.csv) has empty spaces in the descriptor columns. These will be filled with the auto_fill_knn function. You can see the generated values in the file batch_0/test_cluster7a_b0.csv. If you don't want them to be auto-completed, set --not_autofill, in this case, if empty spaces are found, they will not be auto-completed and the program will end."          
        assert any (autofill in line for line in dat_cluster) 
        
        # check the PCA
        pca = f"o GOOD. 82.1 % explained variability. (PC1 34.1 %, PC2 25.6 %, PC3 22.4 %)"          
        assert any (pca in line for line in dat_cluster)  
          
        # check that the origin CSV file has not been modified (with the auto_fill_knn), empty spaces in 'x1' and 'x2'
        #     'x1': [56,  None,   35,   5643,  6536,   6536,   657],
        #     'x2': [65,    65,   654,  None,    62,     62,   245],
        df_test = pd.read_csv(f'{path_tests}/test_cluster7a.csv') 

        assert any (df_test['x1']) is pd.isna(float('nan'))        
        assert any (df_test['x2']) is pd.isna(float('nan'))
        assert (df_test['x3']) is not pd.isna(float('nan'))
        
        # check that the CSV file created in batch_0 folder has the completed df 
        df_test_b0 = pd.read_csv(f'{path_cluster}/batch_0/test_cluster7a_b0.csv') 

        assert (df_test_b0['x1']) is not pd.isna(float('nan'))
        assert (df_test_b0['x2']) is not pd.isna(float('nan')) 
                 
        # check that the options.csv has been created properly   
        options_csv = pd.read_csv('options.csv')

        options_col = ['y', 'csv_name', 'ignore', 'name'] 
        options_values = ['yield', "test_cluster7a.csv","['yield', 'molecules', 'batch']", "molecules"]
        
        for col in options_col:
            assert col in options_csv.columns  
        for value in options_values:
            assert value in options_csv.values

        # using CLUSTER
        cluster(csv_name = f'{path_tests}/{test_job}',
                n_clusters = 2,
                y = 'yield',
                name = 'molecules',
                ignore = []
                )
    
   
    if test_job == "test_cluster7c.csv": 
        subprocess.run(cmd_cluster)
        assert not path.exists(f"{path_cluster}/aqme") 
          
        # open CLUSTER_data.dat to read
        with open("batch_0/CLUSTER_data.dat", "r") as file_cluster: 
            dat_cluster = file_cluster.readlines()
            
        # check the set --categorical "numbers"
        numbers = f"   A total of 1 categorical variables were converted using the numbers mode in the categorical option:   - color"          
        assert any (numbers in line for line in dat_cluster)
        
        # check the PCA
        pca_poor = f"x POOR. 61.4 % explained variability might not be high enough. (PC1 30.7 %, PC2 18.5 %, PC3 12.2 %" 
        pca7c = ' [0.30655755 0.49202404 0.61449856]'          
        assert any (pca_poor in line for line in dat_cluster)
        assert any (pca7c in line for line in dat_cluster)          
          
        # using CLUSTER
        cluster(csv_name = f'{path_tests}/{test_job}',
                n_clusters = 2,
                y = 'yield',
                name = 'molecules',
                categorical = 'numbers',
                ignore = []
                )
        

        


    
        